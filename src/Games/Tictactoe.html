<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tic Tac Toe</title>
    <style>
      body {
        text-align: center;
        font-family: Arial, sans-serif;
        margin: 20px;
      }

      canvas {
        border: 2px solid black;
        display: block;
        margin: 20px auto;
        background-color: #f8f8f8;
      }

      h1 {
        margin-bottom: 10px;
      }

      p {
        margin-bottom: 5px;
      }

      .info {
        font-size: 18px;
        margin-top: 10px;
        color: #333;
      }

      button {
        margin-top: 10px;
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background-color: #007bff;
        color: white;
        border-radius: 5px;
      }

      button:hover {
        background-color: #0056b3;
      }
    </style>
  </head>
  <body>
    <h1>Tic Tac Toe</h1>
    <canvas id="gameBoard" width="300" height="300"></canvas>
    <div class="info" id="gameInfo">Player X's Turn</div>
    <button id="resetButton">Restart Game</button>

    <script>
      const canvas = document.getElementById("gameBoard");
      const ctx = canvas.getContext("2d");
      const gameInfo = document.getElementById("gameInfo");
      const resetButton = document.getElementById("resetButton");

      // Game variables
      const BOARD_SIZE = 3; // The board is 3x3
      const CELL_SIZE = canvas.width / BOARD_SIZE; // Each cell's size
      let board = Array.from({ length: BOARD_SIZE }, () =>
        Array(BOARD_SIZE).fill(null)
      ); // 3x3 array
      let currentPlayer = "X"; // X always starts
      let gameActive = true;

      // Draw the grid
      function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000";

        for (let i = 1; i < BOARD_SIZE; i++) {
          // Vertical lines
          ctx.beginPath();
          ctx.moveTo(i * CELL_SIZE, 0);
          ctx.lineTo(i * CELL_SIZE, canvas.height);
          ctx.stroke();

          // Horizontal lines
          ctx.beginPath();
          ctx.moveTo(0, i * CELL_SIZE);
          ctx.lineTo(canvas.width, i * CELL_SIZE);
          ctx.stroke();
        }
      }

      // Draw X or O on the canvas
      function drawSymbol(x, y, symbol) {
        ctx.lineWidth = 4;

        if (symbol === "X") {
          ctx.strokeStyle = "blue";
          ctx.beginPath();
          // Draw X
          ctx.moveTo(x * CELL_SIZE + 10, y * CELL_SIZE + 10);
          ctx.lineTo((x + 1) * CELL_SIZE - 10, (y + 1) * CELL_SIZE - 10);
          ctx.moveTo((x + 1) * CELL_SIZE - 10, y * CELL_SIZE + 10);
          ctx.lineTo(x * CELL_SIZE + 10, (y + 1) * CELL_SIZE - 10);
          ctx.stroke();
        } else if (symbol === "O") {
          ctx.strokeStyle = "red";
          ctx.beginPath();
          const centerX = x * CELL_SIZE + CELL_SIZE / 2;
          const centerY = y * CELL_SIZE + CELL_SIZE / 2;
          const radius = CELL_SIZE / 3;
          // Draw O
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Check for winner
      function checkWinner() {
        // Check rows, columns, and diagonals
        for (let i = 0; i < BOARD_SIZE; i++) {
          // Check rows
          if (
            board[i][0] &&
            board[i][0] === board[i][1] &&
            board[i][1] === board[i][2]
          ) {
            return board[i][0];
          }

          // Check columns
          if (
            board[0][i] &&
            board[0][i] === board[1][i] &&
            board[1][i] === board[2][i]
          ) {
            return board[0][i];
          }
        }

        // Check primary diagonal
        if (
          board[0][0] &&
          board[0][0] === board[1][1] &&
          board[1][1] === board[2][2]
        ) {
          return board[0][0];
        }

        // Check secondary diagonal
        if (
          board[0][2] &&
          board[0][2] === board[1][1] &&
          board[1][1] === board[2][0]
        ) {
          return board[0][2];
        }

        // Check if the board is fully filled (draw)
        if (board.flat().every((cell) => cell !== null)) {
          return "draw";
        }

        return null;
      }

      // Handle mouse click
      canvas.addEventListener("click", (event) => {
        if (!gameActive) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const x = Math.floor(mouseX / CELL_SIZE);
        const y = Math.floor(mouseY / CELL_SIZE);

        // If the cell is empty, mark it
        if (!board[y][x]) {
          board[y][x] = currentPlayer;
          drawSymbol(x, y, currentPlayer);

          // Check for winner
          const winner = checkWinner();
          if (winner) {
            gameActive = false;
            if (winner === "draw") {
              gameInfo.textContent = "It's a Draw!";
            } else {
              gameInfo.textContent = `Player ${winner} Wins!`;
            }
          } else {
            // Switch player
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            gameInfo.textContent = `Player ${currentPlayer}'s Turn`;
          }
        }
      });

      // Reset the game
      resetButton.addEventListener("click", () => {
        board = Array.from({ length: BOARD_SIZE }, () =>
          Array(BOARD_SIZE).fill(null)
        );
        currentPlayer = "X";
        gameActive = true;
        gameInfo.textContent = `Player ${currentPlayer}'s Turn`;
        drawGrid();
      });

      // Initial render
      drawGrid();
    </script>
  </body>
</html>
